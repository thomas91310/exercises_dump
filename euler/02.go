/*
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
*/

package main

// check for 4,000,000 is done inside the recursion (inside fiboHelper)
func mainFibo() int {
	mem := make(map[int]int)
	keepGoing := true
	i := 0
	for {
		if keepGoing == false {
			break
		}
		_, keepGoing = fiboHelper(i, mem)
		i++
	}
	sum := 0
	for _, val := range mem {
		if val%2 == 0 {
			sum += val
		}
	}
	return sum
}

// check for 4,000,000 is done outside of the recursion
func fiboOtherMain() int {
	mem := make(map[int]int)
	i := 0
	for {
		res := memoizedFibo(i, mem)
		if res > 4000000 {
			break
		}
		i++
	}
	sum := 0
	for _, fiboNumber := range mem {
		if fiboNumber%2 == 0 {
			sum += fiboNumber
		}
	}
	return sum
}

// this is called by mainFibo. Inside check for if we don't go over 4,000,000
func fiboHelper(n int, memoized map[int]int) (int, bool) {
	if n == 0 {
		return 0, true
	}
	if n == 1 {
		return 1, true
	}
	memoizedVal, exists := memoized[n]
	if exists {
		return memoizedVal, true
	}
	v1, _ := fiboHelper(n-1, memoized)
	v2, _ := fiboHelper(n-2, memoized)
	val := v1 + v2
	if val > 4000000 {
		return 0, false
	}
	memoized[n] = val
	return memoized[n], true
}

// normal memoization, nothing more
func memoizedFibo(n int, memoized map[int]int) int {
	if n == 0 {
		return 0
	}
	if n == 1 {
		return 1
	}
	memoizedVal, exists := memoized[n]
	if exists {
		return memoizedVal
	}
	val := memoizedFibo(n-1, memoized) + memoizedFibo(n-2, memoized)
	memoized[n] = val
	return val
}

// normal fibonacci, ... bad
func normalFibo(n int) int {
	if n == 0 {
		return 0
	}
	if n == 1 {
		return 1
	}
	return normalFibo(n-1) + normalFibo(n-2)
}
